#!/bin/sh

# VARS

VERSION=0.0.1
CONFIG=~/.config/taskshrc
DEFAULT_FOLDER=~/tasksh

NAME=$(basename "$0")

if [ -f $CONFIG ]; then
    # shellcheck disable=SC1090
    . $CONFIG
else
    touch $CONFIG
fi

# functions

# shellcheck disable=SC2120
help() {

    WHICH=${1:-general}

    case "$WHICH" in

        general )
            echo "Usage: $NAME [mode] [OPTIONS]..."
            echo "Manage (add, edit, view, etc.) tasks."
            echo 
            echo "$NAME has 8 modes, (a)dd, (ag)enda, (c)onfig, (d)one, (e)dit, (l)ist,"
            echo "(r)emove, and (v)iew."
            echo "Each mode has different functionality, to see usage for use:"
            echo "  $NAME [mode] -h"
            echo "  or"
            echo "  $NAME [mode] --help"
            echo
            echo "For example:"
            echo "  $NAME add -h"
            echo "  or for using the add shorthand"
            echo "  $NAME a -h"
            echo
            echo "There is technically a 9th 'no-mode' mode with two options:"
            echo
            echo "Help:"
            echo "  This gets the general help message for $NAME"
            echo
            echo "  $NAME -h"
            echo "  $NAME --help"
            echo 
            echo "Version:"
            echo "  This gets the $NAME version"
            echo
            echo "  $NAME -v"
            echo "  $NAME --version"

        ;;

        add )
            echo "Usage: $NAME add [TITLE] [OPTIONS]... "
            echo "Usage: $NAME add [OPTIONS]... -- [TITLE] "
            echo "Add a task."
            echo 
            # TODO add remaining docs
        ;;

        agenda )
            echo "Usage: $NAME agenda [OPTIONS]..."
            echo "View your agenda generated based on tasks"
            echo 
            # TODO add remaining docs
        ;;

        config ) 
            echo "Usage: $NAME config [OPTIONS]..."
            echo "Edit $NAME configuration"
            echo 
            # TODO add remaining docs
        ;;

        mark_done )
            echo "Usage:     $NAME done [TASK_ID] [OPTIONS]..."
            echo "Alternate: $NAME done [OPTIONS]..."
            echo "Mark a task as done."
            echo 
            # TODO add remaining docs
        ;; 

        edit )
            echo "Usage:     $NAME edit [TASK_ID] [OPTIONS]..."
            echo "Alternate: $NAME edit [OPTIONS]..."
            echo "Edits an existing task."
            echo 
            # TODO add remaining docs
        ;;

        list )
            echo "Usage: $NAME list [OPTIONS]..."
            echo "List tasks."
            echo 
            # TODO add remaining docs
        ;;

        remove )
            echo "Usage:     $NAME remove [TASK_ID] [OPTIONS]..."
            echo "Alternate: $NAME remove [OPTIONS]..."
            echo "Removes a task"
            echo 
            # TODO add remaining docs
        ;;

        view )
            echo "Usage:     $NAME view [TASK_ID] [OPTIONS]..."
            echo "Alternate: $NAME view [OPTIONS]..."
            echo "View a task."
            echo 
            # TODO add remaining docs
        ;;
        
        * )
            echo "Unknown help section, ERROR"
            exit 1
    esac

    exit 0
}

default() {
    echo TASKSH v$VERSION

    help
}

configure() {
    # check notes dir
    if [ -z ${TASKSH_DIR+x} ]; then
        echo "TASHSH has no folder set."

        echo "Specify a folder TASKSH should use to store data [$DEFAULT_FOLDER]: " 
        read -r FOLDER
        TASKSH_DIR=${FOLDER:-$DEFAULT_FOLDER}

        if [ ! -d "$TASKSH_DIR" ]; then
            create_tasksh_dir

        elif [ "$(ls -A "$TASKSH_DIR")" ]; then
            echo "$TASKSH_DIR is not empty, are you sure you want to use this folder? y/[n]"

            while true; do
                read -r YN
                case "${YN:-n}" in
                    y ) 
                        echo "Successfully created TASKSH folder ($TASKSH_DIR)"
                        if echo "TASKSH_DIR=\"$TASKSH_DIR\"" >> $CONFIG; then
                            echo "Successfully added TASKSH_DIR to TASKSH config"
                        else
                            echo "FAILED to add TASKSH_DIR to TASKSH config"
                            exit 1
                        fi

                        break
                        ;;

                    n ) 
                        echo "TASKSH requires a folder to function, exiting"

                        exit 1
                        ;;

                    * ) echo "Invalid response, input y or n";;
                esac
            done
        fi
    fi

    if [ ! -d "$TASKSH_DIR" ]; then
        create_tasksh_dir
    fi
}

create_tasksh_dir() {
    echo "$TASKSH_DIR does not exist, would you like to create it y/[n]"
            
    while true; do
        read -r YN
        case "${YN:-n}" in
            y ) 
                if mkdir -p "$TASKSH_DIR"; then
                    echo "Successfully created TASKSH folder ($TASKSH_DIR)"
                    if echo "TASKSH_DIR=\"$TASKSH_DIR\"" >> $CONFIG; then
                        echo "Successfully added TASKSH_DIR to TASKSH config"
                    else
                        echo "FAILED to add TASKSH_DIR to TASKSH config"
                        exit 1
                    fi
                else
                    echo "FAILED TO create TASKSH folder ($TASKSH_DIR)"
                    exit 1
                fi

                break
                ;;

            n ) 
                echo "TASKSH requires a folder to function, exiting"

                exit 1
                ;;

            * ) echo "Invalid response, input y or n";;
        esac
    done
}

# Handle configuration
configure

# Mode functions
add() {
    shift # shift over mode

    while [ "$#" -gt 0 ]; do

        case "$1" in

            -d | --due ) 
                if ( echo "${2:--x}" | grep -qe '^-.*' ); then
                    echo "due (-d, --due) requires one argument, got zero"
                    exit 1
                elif ( ! echo "${3:--x}" | grep -qe '^-.*' ); then
                    echo "due (-d, --due) only takes one argument, got more than one"
                    exit 1
                fi

                if ! TASK_DUE=$(date -d "$2" +%s); then
                    echo "ERROR: Invalid date format, dates are parsed via the date command, see date --help for help"
                    exit 1
                fi
                
                shift 2
                ;;

            -s | --schedule ) 

                if ( echo "${2:--x}" | grep -qe '^-.*' ); then
                    echo "schedule (-s, --schedule) requires one argument, got zero"
                    exit 1
                elif ( ! echo "${3:--x}" | grep -qe '^-.*' ); then
                    echo "schedule (-s, --schedule) only takes one argument, got more than one"
                    exit 1
                fi

                if ! TASK_SCHEDULE=$(date -d "$2" +%s); then
                    echo "ERROR: Invalid date format, dates are parsed via the date command, see date --help for help"
                    exit 1
                fi
                
                shift 2
                ;;

            -t | --type )

                if ( echo "${2:--x}" | grep -qe '^-.*' ); then
                    echo "type (-t, --type) requires one argument, got zero"
                    exit 1
                elif ( ! echo "${3:--x}" | grep -qe '^-.*' ); then
                    echo "type (-t, --type) only takes one argument, got more than one"
                    exit 1
                fi

                TASK_TYPE="$2"
                ;;

            -c | --desc | --description )

                if ( echo "${2:--x}" | grep -qe '^-.*' ); then
                    echo "description (-c, --desc, --description) requires one or more arguments"
                    exit 1
                fi

                TASK_DESC="$2"
                shift 2

                while [ "$#" -gt 0 ]; do
                    if ( echo "${1:--x}" | grep -qe '^-.*' ); then
                        break
                    else
                        TASK_DESC="$TASK_DESC $1"
                        shift
                    fi
                done                
                ;;

            -ed | --editor )

                if ( ! echo "${2:--x}" | grep -qe '^-.*' ); then
                    echo "editor (-ed, --editor) takes no arguments, got more than zero"
                    exit 1
                fi

                OPEN_EDITOR=true
                shift
                ;;

            -h | --help)
                help add
                ;;

            -- )
                shift 

                if [ "$#" -eq 0 ] && [ -z ${TASKSH_DIR+x} ]; then
                    echo 'No task title set, a task title is required!'
                    exit 1
                fi

                while [ "$#" -gt 0 ]; do
                    TASK_TITLE="$TASK_TITLE $1"
                    shift
                done
                ;;

            * )
                if ( echo "${1:--x}" | grep -qe '^-.*' ); then
                    echo "$1 is an invalid options, see help (-h, --help) for available options"
                    exit 1
                else
                    TASK_TITLE="$TASK_TITLE $1"
                    shift
                fi
                ;;
        esac 

    done

    # sed -n sed -n 's/^\([0-9][0-9]*\)\.\([a-z][a-z0-9]*\)\.\([A-Za-z0-9][A-Za-z0-9]*\)\.\([A-Z][A-Z]*\)$/\1 \2 \3 \4/p' 

    # \1 -> ID
    # \2 -> timing info
    # \3 -> task type
    # \4 -> status

    # start ID
    TASK_ID=1

    # look in folder, get highest id and increment
    for i in "$TASKSH_DIR"/*; do
        CURRENT_ID=$(basename "$i" | sed -n 's/^\([0-9][0-9]*\)\.\([a-z][a-z0-9]*\)\.\([A-Za-z0-9][A-Za-z0-9]*\)\.\([A-Z][A-Z]*\)$/\1/p')

        : "${CURRENT_ID:=0}"

        if [ "$CURRENT_ID" -ge "$TASK_ID" ]; then
            TASK_ID=$((CURRENT_ID+1))
        fi
    done
 
    # incoporate task id into filename
    TASK_FILENAME="$TASK_ID"

    # # incorporate timing params into filename
    TASK_TIMING="${TASK_SCHEDULE:+s}${TASK_SCHEDULE}"
    TASK_TIMING="$TASK_TIMING${TASK_DUE:+d}${TASK_DUE}"

    if [ "${TASK_TIMING:-}" = '' ]; then
        TASK_FILENAME="$TASK_FILENAME.n"
    else
        TASK_FILENAME="$TASK_FILENAME.$TASK_TIMING"
    fi

    # incorporate type into filename
    TASK_FILENAME="$TASK_FILENAME.${TASK_TYPE-TODO}"

    # add default status
    TASK_FILENAME="$TASK_FILENAME.ACTIVE"

    # make full path
    TASK_PATH="$TASKSH_DIR/$TASK_FILENAME"

    # ensure file does not exist
    if [ -f "$TASK_PATH" ]; then
        echo "ERROR: File already exist despite ID supposedly being incremented"
        echo "this is a error within TASKSH"
        exit 1
    fi

    # create file
    echo "$TASK_DESC" > "$TASK_PATH"

    # open file with EDITOR if specified
    if [ "$OPEN_EDITOR" = true ]; then
        $EDITOR "$TASK_PATH"
    fi
}

agenda() {
    shift 

    SHORT=h # TODO implemented options
    LONG=help

    OPTS=$(getopt -n "$NAME" -o $SHORT -l $LONG -- "$@")
    if [ $? -ne -0 ]; then
        exit 1
    fi

    if [ "$#" -eq 0 ]; then
        help agenda
    fi

    eval set -- "$OPTS"

    while :; do
        case "$1" in # TODO implemented options

        -h | --help)
            help agenda
            ;;

        --)
            shift
            break
            ;;

        *)
            echo "ERROR: Invalid option, see help (-h, --help)" 
            exit 1   
            ;;

        esac
    done
}

config() {
    shift 

    SHORT=h # TODO implemented options
    LONG=help

    OPTS=$(getopt -n "$NAME" -o $SHORT -l $LONG -- "$@")
    if [ $? -ne -0 ]; then
        exit 1
    fi

    if [ "$#" -eq 0 ]; then
        help config
    fi

    eval set -- "$OPTS"

    while :; do
        case "$1" in # TODO implemented options

        -h | --help)
            help config
            ;;

        --)
            shift
            break
            ;;

        *)
            echo "ERROR: Invalid option, see help (-h, --help)" 
            exit 1   
            ;;

        esac
    done
}

mark_done() {
    shift 

    SHORT=h # TODO implemented options
    LONG=help

    OPTS=$(getopt -n "$NAME" -o $SHORT -l $LONG -- "$@")
    if [ $? -ne -0 ]; then
        exit 1
    fi

    if [ "$#" -eq 0 ]; then
        help mark_done
    fi

    eval set -- "$OPTS"

    while :; do
        case "$1" in # TODO implemented options

        -h | --help)
            help mark_done
            ;;

        --)
            shift
            break
            ;;

        *)
            echo "ERROR: Invalid option, see help (-h, --help)" 
            exit 1   
            ;;

        esac
    done
}

edit() {
    shift 

    SHORT=h # TODO implemented options
    LONG=help

    OPTS=$(getopt -n "$NAME" -o $SHORT -l $LONG -- "$@")
    if [ $? -ne -0 ]; then
        exit 1
    fi

    if [ "$#" -eq 0 ]; then
        help edit
    fi

    eval set -- "$OPTS"

    while :; do
        case "$1" in # TODO implemented options

        -h | --help)
            help edit
            ;;

        --)
            shift
            break
            ;;

        *)
            echo "ERROR: Invalid option, see help (-h, --help)" 
            exit 1   
            ;;

        esac
    done
}

list() {
    shift 

    SHORT=h # TODO implemented options
    LONG=help

    OPTS=$(getopt -n "$NAME" -o $SHORT -l $LONG -- "$@")
    if [ $? -ne -0 ]; then
        exit 1
    fi

    if [ "$#" -eq 0 ]; then
        help list
    fi

    eval set -- "$OPTS"

    while :; do
        case "$1" in # TODO implemented options

        -h | --help)
            help list
            ;;

        --)
            shift
            break
            ;;

        *)
            echo "ERROR: Invalid option, see help (-h, --help)" 
            exit 1   
            ;;

        esac
    done
}

remove() {
    shift 

    SHORT=h # TODO implemented options
    LONG=help

    OPTS=$(getopt -n "$NAME" -o $SHORT -l $LONG -- "$@")
    if [ $? -ne -0 ]; then
        exit 1
    fi

    if [ "$#" -eq 0 ]; then
        help remove
    fi

    eval set -- "$OPTS"

    while :; do
        case "$1" in # TODO implemented options

        -h | --help)
            help remove
            ;;

        --)
            shift
            break
            ;;

        *)
            echo "ERROR: Invalid option, see help (-h, --help)" 
            exit 1   
            ;;

        esac
    done
}

view() {
    shift 

    SHORT=h # TODO implemented options
    LONG=help

    OPTS=$(getopt -n "$NAME" -o $SHORT -l $LONG -- "$@")
    if [ $? -ne -0 ]; then
        exit 1
    fi

    if [ "$#" -eq 0 ]; then
        help view
    fi

    eval set -- "$OPTS"

    while :; do
        case "$1" in # TODO implemented options

        -h | --help)
            help view
            ;;

        --)
            shift
            break
            ;;

        *)
            echo "ERROR: Invalid option, see help (-h, --help)" 
            exit 1   
            ;;

        esac
    done
}

# PARSE CLI
if [ "$#" -eq 0 ]; then
    default
fi


## Parse Modes
case "$1" in

    a | add ) 
        add "$@"
        ;;
    
    ag | agenda )
        agenda "$@"
        ;;

    c | config )
        config "$@"
        ;;

    d | done )
        mark_done "$@"
        ;;

    e | edit )
        edit "$@"
        ;;

    l | list )
        list "$@"
        ;;
    
    r | remove )
        remove "$@"
        ;;

    v | view )
        view "$@"
        ;;

    -h | --help )
        help
        ;;

    -v | --version )
        echo v$VERSION
        exit 0
        ;;

    * )
        echo "ERROR: Invalid mode, see help (-h, --help)" 
        exit 1       
esac
